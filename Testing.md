Задания для теста.
Резюме:https://vologda.hh.ru/resume/f8400ff7ff09e13cdd0039ed1f704a586c436a
1. На языке Python реализовать алгоритм (функцию) определения четности целого числа, который будет аналогичен нижеприведенному по функциональности, 
но отличен по своей сути. 
Объяснить плюсы и минусы обеих реализаций.

                Python example:

                def isEven(value):return value%2==0

def chet(value):
  if value%2 == 0:
      print("Chet");
      return 0;
   else:
      print("Nechet")

В моём случае в консоль выводится сообщение о чётности числа, что проще при её тестировании, но дольше при запуске. 
Также проверка проходет через условие, что дольше, чем при прямом возвращении.

2. На языке Python (2.7) реализовать минимум по 2 класса реализовывающих циклический буфер FIFO. Объяснить плюсы и минусы каждой реализации.

1)Встроенный список:
och = [];
 
och.append('one');
och.append('two');
och.append('three');
 
print(och);

Довольно простой в исполнении, однако затрачивает много времени, особенно при большой очереди.
Также при добавлении и удалении элементы сдвигаются на 1 позицию, из-за чего данная операция на длинных очередях занимает много времени.

2)Мультипроцессовая очередь:
from multiprocessing import Queue
och = Queue();
 
och.put('one');
och.put('two');
och.put('three');
 
print(och);

Позволяет парралельно обрабатывать очередь для увеличение производительности и скорости чтения.
Может хранить любой объект.

3. На языке Python реализовать функцию, которая быстрее всего (по процессорным тикам) отсортирует данный ей массив чисел. 
Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным). 
Объяснить почему вы считаете, что функция соответствует заданным критериям.

def sort(massive):
  return massive.sort()
  
 Этот способ будет быстрее, т.к. метод sort() сортирует массив сразу, прямо на месте, без создания нового списка, как в методе sorted().

